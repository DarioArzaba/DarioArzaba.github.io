<!DOCTYPE html> <html lang="es"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width initial-scale=1"> <meta name="author" content="Dario Arzaba"> <meta name="description" content="Capitulo 1: La computadora y los niveles de datosSistema: Conjunto de elementos interrelacionados entre sí para alcanzar un mismo fin.Computadora: Sistema de..."> <title>Unicode</title> <link rel="stylesheet" href="/css/main.css" type="text/css"> <link rel="canonical" href="http://localhost:4000/programacion/2017/05/21/ProgramacionUnicode.html"> <link rel="alternate" type="application/rss+xml" title="" href="http://darioarzaba.github.io/feed.xml"> </head> <body> <div id="particles-js" class="header"> <div class="wrapper"> <h1><a href="http://darioarzaba.github.io">Dario Arzaba</a></h1> <a class="header-btn" href="http://darioarzaba.github.io/feed.xml"> <span class="rss icon" aria-hidden="true"></span> <span class="btn-description">Subscribete</span> </a> </div> </div> <div class="wrapper"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <meta itemprop="wordCount" content="2833"> <link itemprop="url" href="http://localhost:4000/programacion/2017/05/21/ProgramacionUnicode.html"> <meta itemprop="description" content="Capitulo 1: La computadora y los niveles de datos Sistema: Conjunto de elementos interrelacionados entre sí para alcanzar un mismo fin. Computadora: Sistema de dispositivos electrónicos mecánicos y magnéticos que sirven para procesar y almacenar datos. Servidor de alta capacidad, equipo portátil computadora personal, Smart pone, pda o Tablet son ejemplos de computadoras. La computadora esta compuesta por dispositivos electrónicos mecánicos y magnéticos clasificados en: Dispositivos de entrada: (Teclado, Raton, Microfono, Camara): Permiten proporcionar a la computadora los datos a procesar, almacenar o las instrucciones necesarias para la ejecución de una tarea. Dispositivos de salida (Pantalla del monitor): Dispositivos que permiten comunicar resultados al usuario. Dispositivos de procesamiento: Dispositivos encargados de procesar datos, el principal es el CPU o Unidad Central de Procesamiento que contiene a la memoria RAM y al MicroProcesador. La memoria RAM es el área de almacenamiento temporal en donde los programas se cargan para que el CPU pueda acceder a ellos. Nada puede procesarse si no se encuentra en el RAM. La memoria RAM se divide en direcciones de memoria a las que se puede acceder y en las que se puede alojar información en forma de datos de distintos tipos. El microprocesador es el área encargada del trabajo de computo a travez de una unidad aritmética y una unidad lógica. Es por esto que se dice que es una unidad aritmético-logica. La unidad aritmética se encarga de realizar operaciones de suma, resta, división y multiplicación. La unidad lógica resuelve comparaciones y condicionales. Dispositivos de almacenamiento permanente: El disco duro o SSD es en donde almacenamos datos de manera persistente, es decir que no se pierden al apagar el equipo. Dispositivos periféricos: Dispositivos de salida que no forman parte de la computadora pero que pueden conectarse para ampliar su funcionalidad como una impresora o equipos biométricos. El hardware necesita de instrucciones particulares dadas por el software. Sistema Operativo: Conjunto de programas que permiten reconocer, identificar y utilizar el hardware de la computadora. Generalmente cualquier programa tiene que enviar las instrucciones al sistema operativo para que este interpreta la información correctamente a los dispositivos. Programas o Aplicaciones: Conjunto de programas que utilizan de forma genérica las capacidades de la computadora para realziar tareas especificas. Generalmente generan tipos de archivos de trabajo individuales. Sistemas de información: Conjunto de programas que permiten utilizar las capacidades de procesamiento y almacenamiento de la computadora para generar, manipular y divulgar información. Generalmente son creados para empresas o situaciones particulares y no generan archivos sino que únicamente procesas bases de datos. Una configuración de hardware y software particular se denomina entorno o plataforma operativa. Generalmente los programas se enfocan a una plataforma particular, si este programa funciona en varias plataformas tomese en cuenta que aunque su funcionalidad sea la misma su codificación es totalmente especifica. Toda información en la computadora se trabaja en formato binario. Las computadoras no pueden interpretar la importancia y significado de lo que almacenan. Bit: Un bit es un cero o un uno manejado internamente. Son la unidad básica de almacenamiento y son procesados con suma eficiencia por el CPU, los cuales actualmente pueden realizar millones de operaciones lógicas o aritméticas por segundo. Byte: Conjunto de 8 bits que son la cantidad mínima necesaria para representar por medio de operaciones lógico aritméticas a uno de los 256 caracteres que se creria seria el limite máximo de símbolos necesarios en occidente. Sin embargo una computadora podía contar con paginas de códigos que le daban 256 simbolos distintos para lenguajes orientales. Estas paginas de códigos de un solo byte contenían 256 simbolos. Para solucionar el problema de compatibilidad en sistemas que utilzian paginas de códigos distintos se implemento Unicode. UNICODE Un símbolo tiene varias maneras de representarse, en papel con el símbolo A, en sonido con la pronunciación de “Aaah” y en la computadora con el numero decimal 65. Un encoding es el método en el que vinculamos una forma o cantidad de bits o bytes con un símbolo especifico. La misma letra “A” puede ser codificada con distintos sitemas a secuencias de bits diferentes. Cuando una computadora lea o represente un símbolo necesita saber el encoding o método de vinculación para decifrar lo que significa la secuencia de bits. Si uno ve la siguiente secuencia de bits (01000001) o 65 en decimal, la computadora no sabe que significa hasta que lo vinculemos en significado con una tabla de códigos. ASCII y ANSI son carácter sets, estas tablas de códigos vinculan cada numero binario que cabe en un byte con 127 simbolos usando los primeros 7 bits incluyendo caracteres decontrol (Tab, espacio, enter, backspace etc). ASCII no especifica a que se vinculan del 128 al 255. Para resolver el problema de lenguajes extranjeros cada país elaboro code pages con distintos símbolos para los espacios de 128 a 255 manteniendo ASCII semicompatible si se utilziaban solo símbolos en ingles. ASCII realiza su propia versión aumentada de la pagina de códigos. Sin embargo esto no logra solucionar todos los problemas. Unicode Consortium diseña un sistema desde cero, realiza un mapa de todos los caracteres con su representación hexadecimal (que tiene sus versiones decimales y binarias pero en este caso con cientos de ceros). A = U+0041 = 65 En la actualidad el mapa vincula 130,000 simbolos con espacio para 1 millon mas de “Code Points”. Para ver todos los caracteres en (Run – Charmap) o en Unicode.org. Para compatibilidad con ASCII los codepoints desde U+0000 hasta U+007F (0-127) se mantienen a pesar de que todos los caracteres del latin están vinculados en otra parte, esto hacia que cada letra tuviera 2 vinculaciones. La mayoría de los símbolos afuera de ASCII a pesar de que utilizan el eficiente sistema Unicode necesitan 2 bytes para representar un símbolo. En estos 2 bytes se encuentran mapeados los primeros 65,535 simbolos. En encoding es el sistema que transfiere una idea a una serie de bits para que el sistema pueda representar correctamente su símbolo. En este caso el encoding tiene que representar los codepoints del sistema Unicode, si una maquina utiliza el encoding de ASCII para interpretar un documento con letras en Unicode puede interpretar los codepoints de 0 a 127 y simplemente no escribe los que estén mayores a U+0080. Es por esta razón que si se tiene un doucmento en Unicode y posterioremnte se guarda junto con un encoding en ASCII todos los caracteres especiales desaparecen. Debido a la importancia y compatibilidad con ASCII algunos encodings de Unicode transforman los caracteres ASCII a sus valores en ASCII para que sean compatibles por completo con el ASCII encoding. El primer encoding para Unicode simplemente de manera similar a ASCII mapeaba cada símbolo a su representación utilizando 2 bytes. Es decir que utiliza code points desde 0x0000 hasta 0Xffff, en otras palabras desde 0 hasta 65,535. El problema de utilizar 2 bytes para codificar un símbolo es el orden de los bytes. Byte order… algunas computadoras guardan el byte pequeño primero, otras el grande. Se intento llegar a una convención pero había demaciadas computadoras en ambos bandos que organizaban los bytes de manera distinta. Por ello se creo un header que se incluia con el texto llamado BOM (Byte Order Mark), todas las computadoras checan si el BOM esta invertido de ser así cambian el orden de bytes de todo el documento para ajustarse al del sistema. UCS-2 escribe como BOM el codepoint U+FEFF. Si uno abre un UCS-2 y el sistema detecta FEFF entonces los datos están en orden correcto, pero si ve FFEF entonces se tiene que convertir el orden de los bytes. Otro BOM es U+FFEE Sin embargo los problemas eran evidentes, el carácter normalmente no era incluido en el header del documento por los autores o los sitemas, además de que podía ser introducido accidentalmente a la mitad del documento. Se intento estandarizar su uso exclusivo al inicio de un documento pero esta estadarizacion fallo. Los problemas con el orden de los bytes continuaron. ASCII nunca tuvo ese problema pues era un solo byte y este no podía ser malinterpretado. Nota: UCS-2 utiliza un stream de 16 bit. Sin embargo UTF-16 utiliza una secuencia de 20 bits divido en 2 pares de 16bit (32 bit) en donde se acordó no utilizar los últimos 12bit. Cada carácter por si solo no tiene significado pero su unión en un stream y utilizando el encoding correcto produce un solo símbolo. Esta pareja de caracteres invalidos que producen un carácter valido es llamado Surrogate Pair. Unicode Little Endian Byte (BOM FFFE). Unicode Big Endian Byte (BOM FEFF). H = 0x48 en ASCII pero 0x0048 en UCS-2 Este sistema sin embargo tenia varios problemas, el encoding era un poco ineficiente por utilizar un orden de bytes marot. Sin embargo el mayor peligro era el uso de null bytes (0x00) que en el conding de ASCII podía significar un termino del string. En Littleendian alcanzarías a ver la letra antes de que el string se detuviera (0x4800) sin embargo en Bigendian nisiquera alcanza a impirmir la letra (0x0048). UTF-8 es introducido como una alternativa de un solo byte. Esto evita los problemas de rendimiento y el string null que impedia la compatibilidad con ASCII implentando un ingenioso sistema de encoding. Primero que nada los code points 0-007F se guardan igual que ASCII en un solo byte. Code points arriba de 0080 se convierten a binario y se guardan (Encoded) en una serie de bytes que depende de headers en cada byte. El primer byte o “contador” indica el numero de bytes que necesita el codepoint para no malgastar espacio. Estos bytes empiezan con un (11…0) seguido de los espacios necesarios. Es decir: 110xxxxx = necesita 2 bytes. + 10xxxxxx 1110xxxx = necesita 3 bytes + 10xxxxxx + 10xxxxxx 11110xxx = necesita 4 bytes. Los bytes que empiezan con el binario 10xxxxx son bynarios de informacion y contienen el codepont. Al abrir el encoding se eliminan ignoran los headers y solo se interpretan los nuemros en las (x). En cualquier caso UTF-8 tambien necesita de un header para indicar el encoding sino podría ser interpretado como ASCII por un sistema ya que en realidad ocupa exactamente la misma secuencia binaria aunque el encoding sea diferente. UTF-8 sigue utilizando un BOM para los caracteres que necesitan mas de un byte sin embargo este carácter no lo decodifica el sistema sino el mismo encoding. El bom es U+FEFF. Sin embargo algunos sistemas ultrasensibles para el uso de más de un byte neceistan utilizar un sistema especifico denominado UTF-7 el cual también se las ingenia en su encoding para guardar los puntos de Unicode en un solo byte con el uso de símbolos especiales (+ y -) y al guardarlos en base64. El encoding diferencia entre ASCII y UTF-7 si encuentra (-) significa que el carácter es literal (ASCII) de lo contrario es un símbolo UTF-7. Por ejemplo el símbolo de libras en UTF-7 se escirbe como [+AKM-] en donde AKM se decodifica en base64 para dar el codepoint 0x00A3. —————— - Al inicio se utilizaba EBCDIC y se estaba inventando C. Se estandariza en america la tabla de referencia ASCII con todas las letras y los números entre 32 y 127 con espacio siendo 32 y A siendo 65. Toda esta tabla se podía guardar en 7 bits. Los códigos por debajo de 32 no eran imprimibles y solo estaban para control de la computadora. Los primeros 7 causaban sonidos en la computadora y los otros 12 controlaban espacios y demás caracteres para controlar el flujo del papel en una impresora etc. Sin embargo los 128-255 caracteres no habían sido utilizados y varias personas alrededor del mundo diseñaron los sibolos que debían ir en esos bits y su encoding especifico. Por ese entonces IBM lanza su carácter set OEM que fue por varios años el estándar en el mundo occidental y fue el inicio del ASCII ART. Sin embargo OEM no era utilziado en oriente y documentos en Ruso o Chino eran imposibles de intercambiar. Cada sistema de carácter set era llamado Code Page o pagina de códigos. En china y japon los 8 bits completos no alcanzaron y se inventaron el sistema DBCS o Double Byte Character Set, en donde algunos caracteres básicos se almacenaban en un byte y otros en dos bytes. Entonces surje Unicode que fue un intento de guardar todos los símbolos con su repectivo numero binario, decimal, hexadecimal. Muchos creen erróneamente que Unicode es otro carácter set de 16bit que puede almacenar 65.536 caracteres, sin emabrgo Unicode no es un sistema de encoding como ASCII sino un simple mapeo de las letras. Unicode no hizo distinciones como ascii en donde la A era la misma A en cualquier sistema sino que con el uso de fuentes y distintos idiomas la misma letra puede tener varios puntos en el mapeo Unicode representados por U+0000. Un punto en Unicode no es lo mismo que su encoding a binario. Es decir que en ASCII no hay interpretación A = 01000001. Sin embargo en Unicode A = U+0041, ahora Unicode invento distintos encodings para transformar un punto y no un símbolo como tal en el binario correspondiente, dejando la representación a la computadora. Hello en unicode tiene los siguientes code points: U+0048, +0065, + 006C , + 006F Para representar esos códigos en binario primero se utilizo UTF-16 que era un encoding similar a ASCII con la diferencia de que utilizaba 2 bytes, sin embargo no era eficiente por la cantidad de espacio en blanco para caracteres no especiales, el byte que normalmente quedaba en blanco se le denominaba (Low o Little byte), su representación codificada en 2bytes hex: 0048 0065 006C 006C 006F Sin embargo el espacio en blanco no es considerado en este caso y algunos procesadores podían invertir el orden de los bytes en su arquitectura para una mayor procesamiento: 4800 6500 6C00 6C00 6F00 Ambas formas de decodificar los codepoints son validas para algunos CPU y para otros no, esto llevo a introducir in BOM o byte inicial que determinara el orden del documento. Se eligio como BOM FEFF para big byte y FFFE para Little data. En UTF-8 se soluciona el problema de utilizar espacio extra y hace el encoding eficiente para que solo se ocupen los bytes que se necesiten (hasta 6 bytes). Existen otras formas de hacer encoding o codificar los codepints de Unicode como UTF.7 que es similar a UTF-8 sin embargo se limita a un byte. O UTF-4 que utiliza únicamente 4 bytes. Existen otros encodings que son semicompatibles con algunos codepints de Unicode. En Windows se hizo popular utilizar el encoding Windows 1252 (Windows9x Western European Languages). Tambien ISO-8859-1 o Latin-1 se popularisaron sin embargo aunque pueden representar la mayoría de los codepoints iniciales ASCII tienen problemas con idiomas no oxidentales. Hoy en dia para cualquier programador que trabaje con ASCII necesita saber que encoding están utilizando los símbolos para darle significado a los streams de bits. Okay entonces se tenian estas makinas que imprimian numeros, en America se estandarisa ASCII (American Standard Code for Information Interchange). ASCII utilizaba 7 bit, con los que se podian representar 127 valores. De los cuales 32 eran para formato como enter o backspace. • A = 65 que en binario es 1000001 • B = 66 que en binario es 1000010 • C = 67 que en binario es 1000011 • a (minúscula) = 97 que en binario es 1100001 Este estándar en el mundo de habla anglosajona fue perfecto pues permitia la inclusión de todos los símbolos que fueran necesarios. Conforme las necesidades de distintos países variaban simplemente adaptaban algunos símbolos a ASCII. Con la invención de la computadora portátil y la nueva estandarisacion de 8 bit ASCII 2 o ampliado rellena los nuevos espacios, sin embargo los teclados antiguamente semicompatibles de otros lenguajes ahora deciden utilizar el espacio extra para introducir símbolos propios lo que lleva a una tremenda incopatibilidad en el software. Japon en realidad necesitaba tantos símbolos que adapto varios sistemas de carácter encoding de más de 8 bytes pues necesitaban muchos mas símbolos, estos sistemas eran además entre si incompatibles. Sin emabrgo en esos tiempos era común que si querias enviar un documento correctamente a una compañía extranjera lo hicieras por medio de Fax. Pero la llegada del internet fue lo que detono por fin la necesidad de una estandarisacion mundial. Se diseña el Unicode Consortium para resolver este problema. Lo que hacen es vincular cada carácter existente con un “numero oficial” de identificación. Sin embargo ese numero de identificación no contiene la información hacerca de como debe de ser representado, por lo tanto la representación de ese carácter es dependiente del sistema. Cuando una maquina interpreta símbolos en Unicode lo que esta haciendo es representar cada nuevo digito necesario como un uno y un cero: http://www.unicode.org/resources/ http://www.unicode.org/glossary/ http://www.unicode.org/faq/indic.html http://www.unicode.org/faq/font_keyboard.html http://www.unicode.org/faq/utf_bom.html http://www.unicode.org/faq/emoji_dingbats.html http://www.unicode.org/faq/basic_q.html http://www.unicode.org/faq/ http://www.unicode.org/versions/Unicode9.0.0/ http://www.unicode.org/charts/ http://www.unicode.org/ucd/ http://www.unicode.org/reports/index.html#standards http://www.unicode.org/notes/ 01100001 = a 110xxxxx + 10xxxxxx Quita los headers (110 + 10) 1110xxxx + 10xxxxxx + 10xxxxxxx 1111110x + …. —————— "> <meta itemprop="author" content="Dario Arzaba"> <h1 class="post-title" itemprop="headline">Unicode</h1> <ul class="post-meta"> <li aria-label="Category"> <span class="category icon" aria-hidden="true"></span> <a href="/blog/categories/programacion"> Programacion </a> </li> <li aria-label="Publication date"> <span class="calendar icon" aria-hidden="true"></span> <time itemprop="datePublished" datetime="2017-05-21"> 21 May 2017 </time> </li> <li aria-label="Reading time"> <span class="reading icon" aria-hidden="true"></span> About 15 minutes </li> </ul> <div class="content" itemprop="articleBody"> <p>Capitulo 1: La computadora y los niveles de datos Sistema: Conjunto de elementos interrelacionados entre sí para alcanzar un mismo fin. Computadora: Sistema de dispositivos electrónicos mecánicos y magnéticos que sirven para procesar y almacenar datos. Servidor de alta capacidad, equipo portátil computadora personal, Smart pone, pda o Tablet son ejemplos de computadoras. La computadora esta compuesta por dispositivos electrónicos mecánicos y magnéticos clasificados en:</p> <ol> <li>Dispositivos de entrada: (Teclado, Raton, Microfono, Camara): Permiten proporcionar a la computadora los datos a procesar, almacenar o las instrucciones necesarias para la ejecución de una tarea.</li> <li>Dispositivos de salida (Pantalla del monitor): Dispositivos que permiten comunicar resultados al usuario.</li> <li>Dispositivos de procesamiento: Dispositivos encargados de procesar datos, el principal es el CPU o Unidad Central de Procesamiento que contiene a la memoria RAM y al MicroProcesador. La memoria RAM es el área de almacenamiento temporal en donde los programas se cargan para que el CPU pueda acceder a ellos. Nada puede procesarse si no se encuentra en el RAM. La memoria RAM se divide en direcciones de memoria a las que se puede acceder y en las que se puede alojar información en forma de datos de distintos tipos. El microprocesador es el área encargada del trabajo de computo a travez de una unidad aritmética y una unidad lógica. Es por esto que se dice que es una unidad aritmético-logica. La unidad aritmética se encarga de realizar operaciones de suma, resta, división y multiplicación. La unidad lógica resuelve comparaciones y condicionales.</li> <li>Dispositivos de almacenamiento permanente: El disco duro o SSD es en donde almacenamos datos de manera persistente, es decir que no se pierden al apagar el equipo.</li> <li>Dispositivos periféricos: Dispositivos de salida que no forman parte de la computadora pero que pueden conectarse para ampliar su funcionalidad como una impresora o equipos biométricos. El hardware necesita de instrucciones particulares dadas por el software. Sistema Operativo: Conjunto de programas que permiten reconocer, identificar y utilizar el hardware de la computadora. Generalmente cualquier programa tiene que enviar las instrucciones al sistema operativo para que este interpreta la información correctamente a los dispositivos. Programas o Aplicaciones: Conjunto de programas que utilizan de forma genérica las capacidades de la computadora para realziar tareas especificas. Generalmente generan tipos de archivos de trabajo individuales. Sistemas de información: Conjunto de programas que permiten utilizar las capacidades de procesamiento y almacenamiento de la computadora para generar, manipular y divulgar información. Generalmente son creados para empresas o situaciones particulares y no generan archivos sino que únicamente procesas bases de datos. Una configuración de hardware y software particular se denomina entorno o plataforma operativa. Generalmente los programas se enfocan a una plataforma particular, si este programa funciona en varias plataformas tomese en cuenta que aunque su funcionalidad sea la misma su codificación es totalmente especifica. Toda información en la computadora se trabaja en formato binario. Las computadoras no pueden interpretar la importancia y significado de lo que almacenan. Bit: Un bit es un cero o un uno manejado internamente. Son la unidad básica de almacenamiento y son procesados con suma eficiencia por el CPU, los cuales actualmente pueden realizar millones de operaciones lógicas o aritméticas por segundo. Byte: Conjunto de 8 bits que son la cantidad mínima necesaria para representar por medio de operaciones lógico aritméticas a uno de los 256 caracteres que se creria seria el limite máximo de símbolos necesarios en occidente. Sin embargo una computadora podía contar con paginas de códigos que le daban 256 simbolos distintos para lenguajes orientales. Estas paginas de códigos de un solo byte contenían 256 simbolos. Para solucionar el problema de compatibilidad en sistemas que utilzian paginas de códigos distintos se implemento Unicode. UNICODE Un símbolo tiene varias maneras de representarse, en papel con el símbolo A, en sonido con la pronunciación de “Aaah” y en la computadora con el numero decimal 65. Un encoding es el método en el que vinculamos una forma o cantidad de bits o bytes con un símbolo especifico. La misma letra “A” puede ser codificada con distintos sitemas a secuencias de bits diferentes. Cuando una computadora lea o represente un símbolo necesita saber el encoding o método de vinculación para decifrar lo que significa la secuencia de bits. Si uno ve la siguiente secuencia de bits (01000001) o 65 en decimal, la computadora no sabe que significa hasta que lo vinculemos en significado con una tabla de códigos. ASCII y ANSI son carácter sets, estas tablas de códigos vinculan cada numero binario que cabe en un byte con 127 simbolos usando los primeros 7 bits incluyendo caracteres decontrol (Tab, espacio, enter, backspace etc). ASCII no especifica a que se vinculan del 128 al 255. Para resolver el problema de lenguajes extranjeros cada país elaboro code pages con distintos símbolos para los espacios de 128 a 255 manteniendo ASCII semicompatible si se utilziaban solo símbolos en ingles. ASCII realiza su propia versión aumentada de la pagina de códigos. Sin embargo esto no logra solucionar todos los problemas. Unicode Consortium diseña un sistema desde cero, realiza un mapa de todos los caracteres con su representación hexadecimal (que tiene sus versiones decimales y binarias pero en este caso con cientos de ceros). A = U+0041 = 65 En la actualidad el mapa vincula 130,000 simbolos con espacio para 1 millon mas de “Code Points”. Para ver todos los caracteres en (Run – Charmap) o en Unicode.org. Para compatibilidad con ASCII los codepoints desde U+0000 hasta U+007F (0-127) se mantienen a pesar de que todos los caracteres del latin están vinculados en otra parte, esto hacia que cada letra tuviera 2 vinculaciones. La mayoría de los símbolos afuera de ASCII a pesar de que utilizan el eficiente sistema Unicode necesitan 2 bytes para representar un símbolo. En estos 2 bytes se encuentran mapeados los primeros 65,535 simbolos. En encoding es el sistema que transfiere una idea a una serie de bits para que el sistema pueda representar correctamente su símbolo. En este caso el encoding tiene que representar los codepoints del sistema Unicode, si una maquina utiliza el encoding de ASCII para interpretar un documento con letras en Unicode puede interpretar los codepoints de 0 a 127 y simplemente no escribe los que estén mayores a U+0080. Es por esta razón que si se tiene un doucmento en Unicode y posterioremnte se guarda junto con un encoding en ASCII todos los caracteres especiales desaparecen. Debido a la importancia y compatibilidad con ASCII algunos encodings de Unicode transforman los caracteres ASCII a sus valores en ASCII para que sean compatibles por completo con el ASCII encoding. El primer encoding para Unicode simplemente de manera similar a ASCII mapeaba cada símbolo a su representación utilizando 2 bytes. Es decir que utiliza code points desde 0x0000 hasta 0Xffff, en otras palabras desde 0 hasta 65,535. El problema de utilizar 2 bytes para codificar un símbolo es el orden de los bytes. Byte order… algunas computadoras guardan el byte pequeño primero, otras el grande. Se intento llegar a una convención pero había demaciadas computadoras en ambos bandos que organizaban los bytes de manera distinta. Por ello se creo un header que se incluia con el texto llamado BOM (Byte Order Mark), todas las computadoras checan si el BOM esta invertido de ser así cambian el orden de bytes de todo el documento para ajustarse al del sistema. UCS-2 escribe como BOM el codepoint U+FEFF. Si uno abre un UCS-2 y el sistema detecta FEFF entonces los datos están en orden correcto, pero si ve FFEF entonces se tiene que convertir el orden de los bytes. Otro BOM es U+FFEE Sin embargo los problemas eran evidentes, el carácter normalmente no era incluido en el header del documento por los autores o los sitemas, además de que podía ser introducido accidentalmente a la mitad del documento. Se intento estandarizar su uso exclusivo al inicio de un documento pero esta estadarizacion fallo. Los problemas con el orden de los bytes continuaron. ASCII nunca tuvo ese problema pues era un solo byte y este no podía ser malinterpretado. Nota: UCS-2 utiliza un stream de 16 bit. Sin embargo UTF-16 utiliza una secuencia de 20 bits divido en 2 pares de 16bit (32 bit) en donde se acordó no utilizar los últimos 12bit. Cada carácter por si solo no tiene significado pero su unión en un stream y utilizando el encoding correcto produce un solo símbolo. Esta pareja de caracteres invalidos que producen un carácter valido es llamado Surrogate Pair. Unicode Little Endian Byte (BOM FFFE). Unicode Big Endian Byte (BOM FEFF). H = 0x48 en ASCII pero 0x0048 en UCS-2 Este sistema sin embargo tenia varios problemas, el encoding era un poco ineficiente por utilizar un orden de bytes marot. Sin embargo el mayor peligro era el uso de null bytes (0x00) que en el conding de ASCII podía significar un termino del string. En Littleendian alcanzarías a ver la letra antes de que el string se detuviera (0x4800) sin embargo en Bigendian nisiquera alcanza a impirmir la letra (0x0048). UTF-8 es introducido como una alternativa de un solo byte. Esto evita los problemas de rendimiento y el string null que impedia la compatibilidad con ASCII implentando un ingenioso sistema de encoding. Primero que nada los code points 0-007F se guardan igual que ASCII en un solo byte. Code points arriba de 0080 se convierten a binario y se guardan (Encoded) en una serie de bytes que depende de headers en cada byte. El primer byte o “contador” indica el numero de bytes que necesita el codepoint para no malgastar espacio. Estos bytes empiezan con un (11…0) seguido de los espacios necesarios. Es decir: 110xxxxx = necesita 2 bytes. + 10xxxxxx 1110xxxx = necesita 3 bytes + 10xxxxxx + 10xxxxxx 11110xxx = necesita 4 bytes. Los bytes que empiezan con el binario 10xxxxx son bynarios de informacion y contienen el codepont. Al abrir el encoding se eliminan ignoran los headers y solo se interpretan los nuemros en las (x). En cualquier caso UTF-8 tambien necesita de un header para indicar el encoding sino podría ser interpretado como ASCII por un sistema ya que en realidad ocupa exactamente la misma secuencia binaria aunque el encoding sea diferente. UTF-8 sigue utilizando un BOM para los caracteres que necesitan mas de un byte sin embargo este carácter no lo decodifica el sistema sino el mismo encoding. El bom es U+FEFF. Sin embargo algunos sistemas ultrasensibles para el uso de más de un byte neceistan utilizar un sistema especifico denominado UTF-7 el cual también se las ingenia en su encoding para guardar los puntos de Unicode en un solo byte con el uso de símbolos especiales (+ y -) y al guardarlos en base64. El encoding diferencia entre ASCII y UTF-7 si encuentra (-) significa que el carácter es literal (ASCII) de lo contrario es un símbolo UTF-7. Por ejemplo el símbolo de libras en UTF-7 se escirbe como [+AKM-] en donde AKM se decodifica en base64 para dar el codepoint 0x00A3. —————— - Al inicio se utilizaba EBCDIC y se estaba inventando C. Se estandariza en america la tabla de referencia ASCII con todas las letras y los números entre 32 y 127 con espacio siendo 32 y A siendo 65. Toda esta tabla se podía guardar en 7 bits. Los códigos por debajo de 32 no eran imprimibles y solo estaban para control de la computadora. Los primeros 7 causaban sonidos en la computadora y los otros 12 controlaban espacios y demás caracteres para controlar el flujo del papel en una impresora etc. Sin embargo los 128-255 caracteres no habían sido utilizados y varias personas alrededor del mundo diseñaron los sibolos que debían ir en esos bits y su encoding especifico. Por ese entonces IBM lanza su carácter set OEM que fue por varios años el estándar en el mundo occidental y fue el inicio del ASCII ART. Sin embargo OEM no era utilziado en oriente y documentos en Ruso o Chino eran imposibles de intercambiar. Cada sistema de carácter set era llamado Code Page o pagina de códigos. En china y japon los 8 bits completos no alcanzaron y se inventaron el sistema DBCS o Double Byte Character Set, en donde algunos caracteres básicos se almacenaban en un byte y otros en dos bytes. Entonces surje Unicode que fue un intento de guardar todos los símbolos con su repectivo numero binario, decimal, hexadecimal. Muchos creen erróneamente que Unicode es otro carácter set de 16bit que puede almacenar 65.536 caracteres, sin emabrgo Unicode no es un sistema de encoding como ASCII sino un simple mapeo de las letras. Unicode no hizo distinciones como ascii en donde la A era la misma A en cualquier sistema sino que con el uso de fuentes y distintos idiomas la misma letra puede tener varios puntos en el mapeo Unicode representados por U+0000. Un punto en Unicode no es lo mismo que su encoding a binario. Es decir que en ASCII no hay interpretación A = 01000001. Sin embargo en Unicode A = U+0041, ahora Unicode invento distintos encodings para transformar un punto y no un símbolo como tal en el binario correspondiente, dejando la representación a la computadora. Hello en unicode tiene los siguientes code points: U+0048, +0065, + 006C , + 006F Para representar esos códigos en binario primero se utilizo UTF-16 que era un encoding similar a ASCII con la diferencia de que utilizaba 2 bytes, sin embargo no era eficiente por la cantidad de espacio en blanco para caracteres no especiales, el byte que normalmente quedaba en blanco se le denominaba (Low o Little byte), su representación codificada en 2bytes hex: 0048 0065 006C 006C 006F Sin embargo el espacio en blanco no es considerado en este caso y algunos procesadores podían invertir el orden de los bytes en su arquitectura para una mayor procesamiento: 4800 6500 6C00 6C00 6F00 Ambas formas de decodificar los codepoints son validas para algunos CPU y para otros no, esto llevo a introducir in BOM o byte inicial que determinara el orden del documento. Se eligio como BOM FEFF para big byte y FFFE para Little data. En UTF-8 se soluciona el problema de utilizar espacio extra y hace el encoding eficiente para que solo se ocupen los bytes que se necesiten (hasta 6 bytes). Existen otras formas de hacer encoding o codificar los codepints de Unicode como UTF.7 que es similar a UTF-8 sin embargo se limita a un byte. O UTF-4 que utiliza únicamente 4 bytes. Existen otros encodings que son semicompatibles con algunos codepints de Unicode. En Windows se hizo popular utilizar el encoding Windows 1252 (Windows9x Western European Languages). Tambien ISO-8859-1 o Latin-1 se popularisaron sin embargo aunque pueden representar la mayoría de los codepoints iniciales ASCII tienen problemas con idiomas no oxidentales. Hoy en dia para cualquier programador que trabaje con ASCII necesita saber que encoding están utilizando los símbolos para darle significado a los streams de bits. Okay entonces se tenian estas makinas que imprimian numeros, en America se estandarisa ASCII (American Standard Code for Information Interchange). ASCII utilizaba 7 bit, con los que se podian representar 127 valores. De los cuales 32 eran para formato como enter o backspace. • A = 65 que en binario es 1000001 • B = 66 que en binario es 1000010 • C = 67 que en binario es 1000011 • a (minúscula) = 97 que en binario es 1100001 Este estándar en el mundo de habla anglosajona fue perfecto pues permitia la inclusión de todos los símbolos que fueran necesarios. Conforme las necesidades de distintos países variaban simplemente adaptaban algunos símbolos a ASCII. Con la invención de la computadora portátil y la nueva estandarisacion de 8 bit ASCII 2 o ampliado rellena los nuevos espacios, sin embargo los teclados antiguamente semicompatibles de otros lenguajes ahora deciden utilizar el espacio extra para introducir símbolos propios lo que lleva a una tremenda incopatibilidad en el software. Japon en realidad necesitaba tantos símbolos que adapto varios sistemas de carácter encoding de más de 8 bytes pues necesitaban muchos mas símbolos, estos sistemas eran además entre si incompatibles. Sin emabrgo en esos tiempos era común que si querias enviar un documento correctamente a una compañía extranjera lo hicieras por medio de Fax. Pero la llegada del internet fue lo que detono por fin la necesidad de una estandarisacion mundial. Se diseña el Unicode Consortium para resolver este problema. Lo que hacen es vincular cada carácter existente con un “numero oficial” de identificación. Sin embargo ese numero de identificación no contiene la información hacerca de como debe de ser representado, por lo tanto la representación de ese carácter es dependiente del sistema. Cuando una maquina interpreta símbolos en Unicode lo que esta haciendo es representar cada nuevo digito necesario como un uno y un cero: http://www.unicode.org/resources/ http://www.unicode.org/glossary/ http://www.unicode.org/faq/indic.html http://www.unicode.org/faq/font_keyboard.html http://www.unicode.org/faq/utf_bom.html http://www.unicode.org/faq/emoji_dingbats.html http://www.unicode.org/faq/basic_q.html http://www.unicode.org/faq/ http://www.unicode.org/versions/Unicode9.0.0/ http://www.unicode.org/charts/ http://www.unicode.org/ucd/ http://www.unicode.org/reports/index.html#standards http://www.unicode.org/notes/ 01100001 = a 110xxxxx + 10xxxxxx Quita los headers (110 + 10) 1110xxxx + 10xxxxxx + 10xxxxxxx 1111110x + …. ——————</li> </ol> </div> <ul class="tags"> <li><a href="/blog/tags/sistema">Sistema</a></li> <li><a href="/blog/tags/codificacion">Codificacion</a></li> <li><a href="/blog/tags/unicode">Unicode</a></li> <li><a href="/blog/tags/simbolos">Simbolos</a></li> <li><a href="/blog/tags/caracteres">Caracteres</a></li> <li><a href="/blog/tags/bits">Bits</a></li> </ul> <ul class="social-share"> <li> <a class="facebook" target="_blank" rel="nofollow" title="Comparte en Facebook" onclick="window.open(this.href, 'mywin', 'left=200,top=100,width=500,height=300'); return false;" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/programacion/2017/05/21/ProgramacionUnicode.html">Comparte en Facebook</a> </li> <li> <a class="twitter" target="_blank" rel="nofollow" title="Tuitealo" onclick="window.open(this.href, 'mywin', 'left=200,top=100,width=500,height=250'); return false;" href="https://twitter.com/intent/tweet?url=http://localhost:4000/programacion/2017/05/21/ProgramacionUnicode.html&text=Unicode&via=">Tuitealo</a> </li> <li> <a class="linkedin" target="_blank" rel="nofollow" title="Publica en LinkedIn" onclick="window.open(this.href, 'mywin', 'left=200,top=100,width=520,height=570'); return false;" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/programacion/2017/05/21/ProgramacionUnicode.html&title=Unicode&summary=Capitulo%201%3A%20La%20computadora%20y%20los%20niveles%20de%20datos%0ASistema%3A%20Conjunto%20de%20elementos%20interrelacionados%20entre%20s%C3%AD%20para%20alcanzar%20un%20mismo%20fin.%0AComputadora%3A%20Sistema%20de%20dispositivos%20electr%C3%B3nicos%20mec%C3%A1nicos%20y%20magn%C3%A9ticos%20que%20sirven%20para%20procesar%20y%20almacenar%20datos.%0AServidor%20de%20alta%20capacidad%2C%20equipo%20port%C3%A1til%20computadora%20personal%2C%20Smart%20pone%2C%20pda%20o%20Tablet%20son%20ejemplos%20de%20computadoras.%0ALa%20computadora%20esta%20compuesta%20por%20dispositivos%20electr%C3%B3nicos%20mec%C3%A1nicos%20y%20magn%C3%A9ticos%20clasificados%20en%3A%0A%0A%20%20Dispositivos%20de%20entrada%3A%20(Teclado%2C%20Raton%2C%20Microfono%2C%20Camara)%3A%20Permiten%20proporcionar%20a%20la%20computadora%20los%20datos%20a%20procesar%2C%20almacenar%20o%20las%20instrucciones%20necesarias%20para%20la%20ejecuci%C3%B3n%20de%20una%20tarea.%0A%20%20Dispositivos%20de%20salida%20(Pantalla%20del%20monitor)%3A%20Dispositivos%20que%20permiten%20comunicar%20resultados%20al%20usuario.%0A%20%20Dispositivos%20de%20procesamiento%3A%20Dispositivos%20encargados%20de%20procesar%20datos%2C%20el%20principal%20es%20el%20CPU%20o%20Unidad%20Central%20de%20Procesamiento%20que%20contiene%20a%20la%20memoria%20RAM%20y%20al%20MicroProcesador.%20La%20memoria%20RAM%20es%20el%20%C3%A1rea%20de%20almacenamiento%20temporal%20en%20donde%20los%20programas%20se%20cargan%20para%20que%20el%20CPU%20pueda%20acceder%20a%20ellos.%20Nada%20puede%20procesarse%20si%20no%20se%20encuentra%20en%20el%20RAM.%20La%20memoria%20RAM%20se%20divide%20en%20direcciones%20de%20memoria%20a%20las%20que%20se%20puede%20acceder%20y%20en%20las%20que%20se%20puede%20alojar%20informaci%C3%B3n%20en%20forma%20de%20datos%20de%20distintos%20tipos.%20El%20microprocesador%20es%20el%20%C3%A1rea%20encargada%20del%20trabajo%20de%20computo%20a%20travez%20de%20una%20unidad%20aritm%C3%A9tica%20y%20una%20unidad%20l%C3%B3gica.%20Es%20por%20esto%20que%20se%20dice%20que%20es%20una%20unidad%20aritm%C3%A9tico-logica.%20La%20unidad%20aritm%C3%A9tica%20se%20encarga%20de%20realizar%20operaciones%20de%20suma%2C%20resta%2C%20divisi%C3%B3n%20y%20multiplicaci%C3%B3n.%20La%20unidad%20l%C3%B3gica%20resuelve%20comparaciones%20y%20condicionales.%0A%20%20Dispositivos%20de%20almacenamiento%20permanente%3A%20El%20disco%20duro%20o%20SSD%20es%20en%20donde%20almacenamos%20datos%20de%20manera%20persistente%2C%20es%20decir%20que%20no%20se%20pierden%20al%20apagar%20el%20equipo.%0A%20%20Dispositivos%20perif%C3%A9ricos%3A%20Dispositivos%20de%20salida%20que%20no%20forman%20parte%20de%20la%20computadora%20pero%20que%20pueden%20conectarse%20para%20ampliar%20su%20funcionalidad%20como%20una%20impresora%20o%20equipos%20biom%C3%A9tricos.%0AEl%20hardware%20necesita%20de%20instrucciones%20particulares%20dadas%20por%20el%20software.%0ASistema%20Operativo%3A%20Conjunto%20de%20programas%20que%20permiten%20reconocer%2C%20identificar%20y%20utilizar%20el%20hardware%20de%20la%20computadora.%20Generalmente%20cualquier%20programa%20tiene%20que%20enviar%20las%20instrucciones%20al%20sistema%20operativo%20para%20que%20este%20interpreta%20la%20informaci%C3%B3n%20correctamente%20a%20los%20dispositivos.%0AProgramas%20o%20Aplicaciones%3A%20Conjunto%20de%20programas%20que%20utilizan%20de%20forma%20gen%C3%A9rica%20las%20capacidades%20de%20la%20computadora%20para%20realziar%20tareas%20especificas.%20Generalmente%20generan%20tipos%20de%20archivos%20de%20trabajo%20individuales.%0ASistemas%20de%20informaci%C3%B3n%3A%20Conjunto%20de%20programas%20que%20permiten%20utilizar%20las%20capacidades%20de%20procesamiento%20y%20almacenamiento%20de%20la%20computadora%20para%20generar%2C%20manipular%20y%20divulgar%20informaci%C3%B3n.%20Generalmente%20son%20creados%20para%20empresas%20o%20situaciones%20particulares%20y%20no%20generan%20archivos%20sino%20que%20%C3%BAnicamente%20procesas%20bases%20de%20datos.%0AUna%20configuraci%C3%B3n%20de%20hardware%20y%20software%20particular%20se%20denomina%20entorno%20o%20plataforma%20operativa.%20Generalmente%20los%20programas%20se%20enfocan%20a%20una%20plataforma%20particular%2C%20si%20este%20programa%20funciona%20en%20varias%20plataformas%20tomese%20en%20cuenta%20que%20aunque%20su%20funcionalidad%20sea%20la%20misma%20su%20codificaci%C3%B3n%20es%20totalmente%20especifica.%0AToda%20informaci%C3%B3n%20en%20la%20computadora%20se%20trabaja%20en%20formato%20binario.%20Las%20computadoras%20no%20pueden%20interpretar%20la%20importancia%20y%20significado%20de%20lo%20que%20almacenan.%0ABit%3A%20Un%20bit%20es%20un%20cero%20o%20un%20uno%20manejado%20internamente.%20Son%20la%20unidad%20b%C3%A1sica%20de%20almacenamiento%20y%20son%20procesados%20con%20suma%20eficiencia%20por%20el%20CPU%2C%20los%20cuales%20actualmente%20pueden%20realizar%20millones%20de%20operaciones%20l%C3%B3gicas%20o%20aritm%C3%A9ticas%20por%20segundo.%0AByte%3A%20Conjunto%20de%208%20bits%20que%20son%20la%20cantidad%20m%C3%ADnima%20necesaria%20para%20representar%20por%20medio%20de%20operaciones%20l%C3%B3gico%20aritm%C3%A9ticas%20a%20uno%20de%20los%20256%20caracteres%20que%20se%20creria%20seria%20el%20limite%20m%C3%A1ximo%20de%20s%C3%ADmbolos%20necesarios%20en%20occidente.%0ASin%20embargo%20una%20computadora%20pod%C3%ADa%20contar%20con%20paginas%20de%20c%C3%B3digos%20que%20le%20daban%20256%20simbolos%20distintos%20para%20lenguajes%20orientales.%20Estas%20paginas%20de%20c%C3%B3digos%20de%20un%20solo%20byte%20conten%C3%ADan%20256%20simbolos.%0APara%20solucionar%20el%20problema%20de%20compatibilidad%20en%20sistemas%20que%20utilzian%20paginas%20de%20c%C3%B3digos%20distintos%20se%20implemento%20Unicode.%0AUNICODE%0AUn%20s%C3%ADmbolo%20tiene%20varias%20maneras%20de%20representarse%2C%20en%20papel%20con%20el%20s%C3%ADmbolo%20A%2C%20en%20sonido%20con%20la%20pronunciaci%C3%B3n%20de%20%E2%80%9CAaah%E2%80%9D%20y%20en%20la%20computadora%20con%20el%20numero%20decimal%2065.%0AUn%20encoding%20es%20el%20m%C3%A9todo%20en%20el%20que%20vinculamos%20una%20forma%20o%20cantidad%20de%20bits%20o%20bytes%20con%20un%20s%C3%ADmbolo%20especifico.%20La%20misma%20letra%20%E2%80%9CA%E2%80%9D%20puede%20ser%20codificada%20con%20distintos%20sitemas%20a%20secuencias%20de%20bits%20diferentes.%0ACuando%20una%20computadora%20lea%20o%20represente%20un%20s%C3%ADmbolo%20necesita%20saber%20el%20encoding%20o%20m%C3%A9todo%20de%20vinculaci%C3%B3n%20para%20decifrar%20lo%20que%20significa%20la%20secuencia%20de%20bits.%20Si%20uno%20ve%20la%20siguiente%20secuencia%20de%20bits%20(01000001)%20o%2065%20en%20decimal%2C%20la%20computadora%20no%20sabe%20que%20significa%20hasta%20que%20lo%20vinculemos%20en%20significado%20con%20una%20tabla%20de%20c%C3%B3digos.%0AASCII%20y%20ANSI%20son%20car%C3%A1cter%20sets%2C%20estas%20tablas%20de%20c%C3%B3digos%20vinculan%20cada%20numero%20binario%20que%20cabe%20en%20un%20byte%20con%20127%20simbolos%20usando%20los%20primeros%207%20bits%20incluyendo%20caracteres%20decontrol%20(Tab%2C%20espacio%2C%20enter%2C%20backspace%20etc).%20ASCII%20no%20especifica%20a%20que%20se%20vinculan%20del%20128%20al%20255.%0APara%20resolver%20el%20problema%20de%20lenguajes%20extranjeros%20cada%20pa%C3%ADs%20elaboro%20code%20pages%20con%20distintos%20s%C3%ADmbolos%20para%20los%20espacios%20de%20128%20a%20255%20manteniendo%20ASCII%20semicompatible%20si%20se%20utilziaban%20solo%20s%C3%ADmbolos%20en%20ingles.%20%0AASCII%20realiza%20su%20propia%20versi%C3%B3n%20aumentada%20de%20la%20pagina%20de%20c%C3%B3digos.%20Sin%20embargo%20esto%20no%20logra%20solucionar%20todos%20los%20problemas.%20Unicode%20Consortium%20dise%C3%B1a%20un%20sistema%20desde%20cero%2C%20realiza%20un%20mapa%20de%20todos%20los%20caracteres%20con%20su%20representaci%C3%B3n%20hexadecimal%20(que%20tiene%20sus%20versiones%20decimales%20y%20binarias%20pero%20en%20este%20caso%20con%20cientos%20de%20ceros).%0AA%20%3D%20U%2B0041%20%3D%2065%0AEn%20la%20actualidad%20el%20mapa%20vincula%20130%2C000%20simbolos%20con%20espacio%20para%201%20millon%20mas%20de%20%E2%80%9CCode%20Points%E2%80%9D.%20Para%20ver%20todos%20los%20caracteres%20en%20(Run%20%E2%80%93%20Charmap)%20o%20en%20Unicode.org.%0APara%20compatibilidad%20con%20ASCII%20los%20codepoints%20desde%20U%2B0000%20hasta%20U%2B007F%20(0-127)%20se%20mantienen%20a%20pesar%20de%20que%20todos%20los%20caracteres%20del%20latin%20est%C3%A1n%20vinculados%20en%20otra%20parte%2C%20esto%20hacia%20que%20cada%20letra%20tuviera%202%20vinculaciones.%0ALa%20mayor%C3%ADa%20de%20los%20s%C3%ADmbolos%20afuera%20de%20ASCII%20a%20pesar%20de%20que%20utilizan%20el%20eficiente%20sistema%20Unicode%20necesitan%202%20bytes%20para%20representar%20un%20s%C3%ADmbolo.%20En%20estos%202%20bytes%20se%20encuentran%20mapeados%20los%20primeros%2065%2C535%20simbolos.%0AEn%20encoding%20es%20el%20sistema%20que%20transfiere%20una%20idea%20a%20una%20serie%20de%20bits%20para%20que%20el%20sistema%20pueda%20representar%20correctamente%20su%20s%C3%ADmbolo.%20En%20este%20caso%20el%20encoding%20tiene%20que%20representar%20los%20codepoints%20del%20sistema%20Unicode%2C%20si%20una%20maquina%20utiliza%20el%20encoding%20de%20ASCII%20para%20interpretar%20un%20documento%20con%20letras%20en%20Unicode%20puede%20interpretar%20los%20codepoints%20de%200%20a%20127%20y%20simplemente%20no%20escribe%20los%20que%20est%C3%A9n%20mayores%20a%20U%2B0080.%0AEs%20por%20esta%20raz%C3%B3n%20que%20si%20se%20tiene%20un%20doucmento%20en%20Unicode%20y%20posterioremnte%20se%20guarda%20junto%20con%20un%20encoding%20en%20ASCII%20todos%20los%20caracteres%20especiales%20desaparecen.%0ADebido%20a%20la%20importancia%20y%20compatibilidad%20con%20ASCII%20algunos%20encodings%20de%20Unicode%20transforman%20los%20caracteres%20ASCII%20a%20sus%20valores%20en%20ASCII%20para%20que%20sean%20compatibles%20por%20completo%20con%20el%20ASCII%20encoding.%0AEl%20primer%20encoding%20para%20Unicode%20simplemente%20de%20manera%20similar%20a%20ASCII%20mapeaba%20cada%20s%C3%ADmbolo%20a%20su%20representaci%C3%B3n%20utilizando%202%20bytes.%20Es%20decir%20que%20utiliza%20code%20points%20desde%200x0000%20hasta%200Xffff%2C%20en%20otras%20palabras%20desde%200%20hasta%2065%2C535.%20El%20problema%20de%20utilizar%202%20bytes%20para%20codificar%20un%20s%C3%ADmbolo%20es%20el%20orden%20de%20los%20bytes.%0AByte%20order%E2%80%A6%20algunas%20computadoras%20guardan%20el%20byte%20peque%C3%B1o%20primero%2C%20otras%20el%20grande.%20Se%20intento%20llegar%20a%20una%20convenci%C3%B3n%20pero%20hab%C3%ADa%20demaciadas%20computadoras%20en%20ambos%20bandos%20que%20organizaban%20los%20bytes%20de%20manera%20distinta.%20Por%20ello%20se%20creo%20un%20header%20que%20se%20incluia%20con%20el%20texto%20llamado%20BOM%20(Byte%20Order%20Mark)%2C%20todas%20las%20computadoras%20checan%20si%20el%20BOM%20esta%20invertido%20de%20ser%20as%C3%AD%20cambian%20el%20orden%20de%20bytes%20de%20todo%20el%20documento%20para%20ajustarse%20al%20del%20sistema.%0AUCS-2%20escribe%20como%20BOM%20el%20codepoint%20U%2BFEFF.%20Si%20uno%20abre%20un%20UCS-2%20y%20el%20sistema%20detecta%20FEFF%20entonces%20los%20datos%20est%C3%A1n%20en%20orden%20correcto%2C%20pero%20si%20ve%20FFEF%20entonces%20se%20tiene%20que%20convertir%20el%20orden%20de%20los%20bytes.%20Otro%20BOM%20es%20U%2BFFEE%0ASin%20embargo%20los%20problemas%20eran%20evidentes%2C%20el%20car%C3%A1cter%20normalmente%20no%20era%20incluido%20en%20el%20header%20del%20documento%20por%20los%20autores%20o%20los%20sitemas%2C%20adem%C3%A1s%20de%20que%20pod%C3%ADa%20ser%20introducido%20accidentalmente%20a%20la%20mitad%20del%20documento.%20Se%20intento%20estandarizar%20su%20uso%20exclusivo%20al%20inicio%20de%20un%20documento%20pero%20esta%20estadarizacion%20fallo.%0ALos%20problemas%20con%20el%20orden%20de%20los%20bytes%20continuaron.%20ASCII%20nunca%20tuvo%20ese%20problema%20pues%20era%20un%20solo%20byte%20y%20este%20no%20pod%C3%ADa%20ser%20malinterpretado.%0ANota%3A%20UCS-2%20utiliza%20un%20stream%20de%2016%20bit.%20Sin%20embargo%20UTF-16%20utiliza%20una%20secuencia%20de%2020%20bits%20divido%20en%202%20pares%20de%2016bit%20(32%20bit)%20en%20donde%20se%20acord%C3%B3%20no%20utilizar%20los%20%C3%BAltimos%2012bit.%20Cada%20car%C3%A1cter%20por%20si%20solo%20no%20tiene%20significado%20pero%20su%20uni%C3%B3n%20en%20un%20stream%20y%20utilizando%20el%20encoding%20correcto%20produce%20un%20solo%20s%C3%ADmbolo.%20Esta%20pareja%20de%20caracteres%20invalidos%20que%20producen%20un%20car%C3%A1cter%20valido%20es%20llamado%20Surrogate%20Pair.%0AUnicode%20Little%20Endian%20Byte%20(BOM%20FFFE).%0AUnicode%20Big%20Endian%20Byte%20(BOM%20FEFF).%0AH%20%3D%200x48%20en%20ASCII%20pero%200x0048%20en%20UCS-2%0AEste%20sistema%20sin%20embargo%20tenia%20varios%20problemas%2C%20el%20encoding%20era%20un%20poco%20ineficiente%20por%20utilizar%20un%20orden%20de%20bytes%20marot.%20Sin%20embargo%20el%20mayor%20peligro%20era%20el%20uso%20de%20null%20bytes%20(0x00)%20que%20en%20el%20conding%20de%20ASCII%20pod%C3%ADa%20significar%20un%20termino%20del%20string.%0AEn%20Littleendian%20alcanzar%C3%ADas%20a%20ver%20la%20letra%20antes%20de%20que%20el%20string%20se%20detuviera%20(0x4800)%20sin%20embargo%20en%20Bigendian%20nisiquera%20alcanza%20a%20impirmir%20la%20letra%20(0x0048).%0AUTF-8%20es%20introducido%20como%20una%20alternativa%20de%20un%20solo%20byte.%20Esto%20evita%20los%20problemas%20de%20rendimiento%20y%20el%20string%20null%20que%20impedia%20la%20compatibilidad%20con%20ASCII%20implentando%20un%20ingenioso%20sistema%20de%20encoding.%0APrimero%20que%20nada%20los%20code%20points%200-007F%20se%20guardan%20igual%20que%20ASCII%20en%20un%20solo%20byte.%0ACode%20points%20arriba%20de%200080%20se%20convierten%20a%20binario%20y%20se%20guardan%20(Encoded)%20en%20una%20serie%20de%20bytes%20que%20depende%20de%20headers%20en%20cada%20byte.%0AEl%20primer%20byte%20o%20%E2%80%9Ccontador%E2%80%9D%20indica%20el%20numero%20de%20bytes%20que%20necesita%20el%20codepoint%20para%20no%20malgastar%20espacio.%20Estos%20bytes%20empiezan%20con%20un%20(11%E2%80%A60)%20seguido%20de%20los%20espacios%20necesarios.%20Es%20decir%3A%0A110xxxxx%20%3D%20necesita%202%20bytes.%20%2B%2010xxxxxx%0A1110xxxx%20%3D%20necesita%203%20bytes%20%2B%2010xxxxxx%20%2B%2010xxxxxx%0A11110xxx%20%3D%20necesita%204%20bytes.%0ALos%20bytes%20que%20empiezan%20con%20el%20binario%2010xxxxx%20son%20bynarios%20de%20informacion%20y%20contienen%20el%20codepont.%20Al%20abrir%20el%20encoding%20se%20eliminan%20ignoran%20los%20headers%20y%20solo%20se%20interpretan%20los%20nuemros%20en%20las%20(x).%0AEn%20cualquier%20caso%20UTF-8%20tambien%20necesita%20de%20un%20header%20para%20indicar%20el%20encoding%20sino%20podr%C3%ADa%20ser%20interpretado%20como%20ASCII%20por%20un%20sistema%20ya%20que%20en%20realidad%20ocupa%20exactamente%20la%20misma%20secuencia%20binaria%20aunque%20el%20encoding%20sea%20diferente.%0AUTF-8%20sigue%20utilizando%20un%20BOM%20para%20los%20caracteres%20que%20necesitan%20mas%20de%20un%20byte%20sin%20embargo%20este%20car%C3%A1cter%20no%20lo%20decodifica%20el%20sistema%20sino%20el%20mismo%20encoding.%20El%20bom%20es%20U%2BFEFF.%0ASin%20embargo%20algunos%20sistemas%20ultrasensibles%20para%20el%20uso%20de%20m%C3%A1s%20de%20un%20byte%20neceistan%20utilizar%20un%20sistema%20especifico%20denominado%20UTF-7%20el%20cual%20tambi%C3%A9n%20se%20las%20ingenia%20en%20su%20encoding%20para%20guardar%20los%20puntos%20de%20Unicode%20en%20un%20solo%20byte%20con%20el%20uso%20de%20s%C3%ADmbolos%20especiales%20(%2B%20y%20-)%20y%20al%20guardarlos%20en%20base64.%0AEl%20encoding%20diferencia%20entre%20ASCII%20y%20UTF-7%20si%20encuentra%20(-)%20significa%20que%20el%20car%C3%A1cter%20es%20literal%20(ASCII)%20de%20lo%20contrario%20es%20un%20s%C3%ADmbolo%20UTF-7.%20Por%20ejemplo%20el%20s%C3%ADmbolo%20de%20libras%20en%20UTF-7%20se%20escirbe%20como%20%5B%2BAKM-%5D%20en%20donde%20AKM%20se%20decodifica%20en%20base64%20para%20dar%20el%20codepoint%200x00A3.%0A%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%20-%20%0AAl%20inicio%20se%20utilizaba%20EBCDIC%20y%20se%20estaba%20inventando%20C.%0ASe%20estandariza%20en%20america%20la%20tabla%20de%20referencia%20ASCII%20con%20todas%20las%20letras%20y%20los%20n%C3%BAmeros%20entre%2032%20y%20127%20con%20espacio%20siendo%2032%20y%20A%20siendo%2065.%20Toda%20esta%20tabla%20se%20pod%C3%ADa%20guardar%20en%207%20bits.%0ALos%20c%C3%B3digos%20por%20debajo%20de%2032%20no%20eran%20imprimibles%20y%20solo%20estaban%20para%20control%20de%20la%20computadora.%20Los%20primeros%207%20causaban%20sonidos%20en%20la%20computadora%20y%20los%20otros%2012%20controlaban%20espacios%20y%20dem%C3%A1s%20caracteres%20para%20controlar%20el%20flujo%20del%20papel%20en%20una%20impresora%20etc.%0ASin%20embargo%20los%20128-255%20caracteres%20no%20hab%C3%ADan%20sido%20utilizados%20y%20varias%20personas%20alrededor%20del%20mundo%20dise%C3%B1aron%20los%20sibolos%20que%20deb%C3%ADan%20ir%20en%20esos%20bits%20y%20su%20encoding%20especifico.%20Por%20ese%20entonces%20IBM%20lanza%20su%20car%C3%A1cter%20set%20OEM%20que%20fue%20por%20varios%20a%C3%B1os%20el%20est%C3%A1ndar%20en%20el%20mundo%20occidental%20y%20fue%20el%20inicio%20del%20ASCII%20ART.%0ASin%20embargo%20OEM%20no%20era%20utilziado%20en%20oriente%20y%20documentos%20en%20Ruso%20o%20Chino%20eran%20imposibles%20de%20intercambiar.%20Cada%20sistema%20de%20car%C3%A1cter%20set%20era%20llamado%20Code%20Page%20o%20pagina%20de%20c%C3%B3digos.%0AEn%20china%20y%20japon%20los%208%20bits%20completos%20no%20alcanzaron%20y%20se%20inventaron%20el%20sistema%20DBCS%20o%20Double%20Byte%20Character%20Set%2C%20en%20donde%20algunos%20caracteres%20b%C3%A1sicos%20se%20almacenaban%20en%20un%20byte%20y%20otros%20en%20dos%20bytes.%0AEntonces%20surje%20Unicode%20que%20fue%20un%20intento%20de%20guardar%20todos%20los%20s%C3%ADmbolos%20con%20su%20repectivo%20numero%20binario%2C%20decimal%2C%20hexadecimal.%20Muchos%20creen%20err%C3%B3neamente%20que%20Unicode%20es%20otro%20car%C3%A1cter%20set%20de%2016bit%20que%20puede%20almacenar%2065.536%20caracteres%2C%20sin%20emabrgo%20Unicode%20no%20es%20un%20sistema%20de%20encoding%20como%20ASCII%20sino%20un%20simple%20mapeo%20de%20las%20letras.%0AUnicode%20no%20hizo%20distinciones%20como%20ascii%20en%20donde%20la%20A%20era%20la%20misma%20A%20en%20cualquier%20sistema%20sino%20que%20con%20el%20uso%20de%20fuentes%20y%20distintos%20idiomas%20la%20misma%20letra%20puede%20tener%20varios%20puntos%20en%20el%20mapeo%20Unicode%20representados%20por%20U%2B0000.%0AUn%20punto%20en%20Unicode%20no%20es%20lo%20mismo%20que%20su%20encoding%20a%20binario.%20Es%20decir%20que%20en%20ASCII%20no%20hay%20interpretaci%C3%B3n%20A%20%3D%2001000001.%20Sin%20embargo%20en%20Unicode%20A%20%3D%20U%2B0041%2C%20ahora%20Unicode%20invento%20distintos%20encodings%20para%20transformar%20un%20punto%20y%20no%20un%20s%C3%ADmbolo%20como%20tal%20en%20el%20binario%20correspondiente%2C%20dejando%20la%20representaci%C3%B3n%20a%20la%20computadora.%0AHello%20en%20unicode%20tiene%20los%20siguientes%20code%20points%3A%20U%2B0048%2C%20%2B0065%2C%20%2B%20006C%20%2C%20%2B%20006F%0APara%20representar%20esos%20c%C3%B3digos%20en%20binario%20primero%20se%20utilizo%20UTF-16%20que%20era%20un%20encoding%20similar%20a%20ASCII%20con%20la%20diferencia%20de%20que%20utilizaba%202%20bytes%2C%20sin%20embargo%20no%20era%20eficiente%20por%20la%20cantidad%20de%20espacio%20en%20blanco%20para%20caracteres%20no%20especiales%2C%20el%20byte%20que%20normalmente%20quedaba%20en%20blanco%20se%20le%20denominaba%20(Low%20o%20Little%20byte)%2C%20su%20representaci%C3%B3n%20codificada%20en%202bytes%20hex%3A%0A0048%200065%20006C%20006C%20006F%0ASin%20embargo%20el%20espacio%20en%20blanco%20no%20es%20considerado%20en%20este%20caso%20y%20algunos%20procesadores%20pod%C3%ADan%20invertir%20el%20orden%20de%20los%20bytes%20en%20su%20arquitectura%20para%20una%20mayor%20procesamiento%3A%0A4800%206500%206C00%206C00%206F00%0AAmbas%20formas%20de%20decodificar%20los%20codepoints%20son%20validas%20para%20algunos%20CPU%20y%20para%20otros%20no%2C%20esto%20llevo%20a%20introducir%20in%20BOM%20o%20byte%20inicial%20que%20determinara%20el%20orden%20del%20documento.%20Se%20eligio%20como%20BOM%20FEFF%20para%20big%20byte%20y%20FFFE%20para%20Little%20data.%0AEn%20UTF-8%20se%20soluciona%20el%20problema%20de%20utilizar%20espacio%20extra%20y%20hace%20el%20encoding%20eficiente%20para%20que%20solo%20se%20ocupen%20los%20bytes%20que%20se%20necesiten%20(hasta%206%20bytes).%0AExisten%20otras%20formas%20de%20hacer%20encoding%20o%20codificar%20los%20codepints%20de%20Unicode%20como%20UTF.7%20que%20es%20similar%20a%20UTF-8%20sin%20embargo%20se%20limita%20a%20un%20byte.%20O%20UTF-4%20que%20utiliza%20%C3%BAnicamente%204%20bytes.%20Existen%20otros%20encodings%20que%20son%20semicompatibles%20con%20algunos%20codepints%20de%20Unicode.%0AEn%20Windows%20se%20hizo%20popular%20utilizar%20el%20encoding%20Windows%201252%20(Windows9x%20Western%20European%20Languages).%20Tambien%20ISO-8859-1%20o%20Latin-1%20se%20popularisaron%20sin%20embargo%20aunque%20pueden%20representar%20la%20mayor%C3%ADa%20de%20los%20codepoints%20iniciales%20ASCII%20tienen%20problemas%20con%20idiomas%20no%20oxidentales.%0AHoy%20en%20dia%20para%20cualquier%20programador%20que%20trabaje%20con%20ASCII%20necesita%20saber%20que%20encoding%20est%C3%A1n%20utilizando%20los%20s%C3%ADmbolos%20para%20darle%20significado%20a%20los%20streams%20de%20bits.%0AOkay%20entonces%20se%20tenian%20estas%20makinas%20que%20imprimian%20numeros%2C%20en%20America%20se%20estandarisa%20ASCII%20(American%20Standard%20Code%20for%20Information%20Interchange).%20ASCII%20utilizaba%207%20bit%2C%20con%20los%20que%20se%20podian%20representar%20127%20valores.%20De%20los%20cuales%2032%20eran%20para%20formato%20como%20enter%20o%20backspace.%0A%E2%80%A2%09A%20%3D%2065%20que%20en%20binario%20es%201000001%0A%E2%80%A2%09B%20%3D%2066%20que%20en%20binario%20es%201000010%0A%E2%80%A2%09C%20%3D%2067%20que%20en%20binario%20es%201000011%0A%E2%80%A2%09a%20(min%C3%BAscula)%20%3D%2097%20que%20en%20binario%20es%201100001%0AEste%20est%C3%A1ndar%20en%20el%20mundo%20de%20habla%20anglosajona%20fue%20perfecto%20pues%20permitia%20la%20inclusi%C3%B3n%20de%20todos%20los%20s%C3%ADmbolos%20que%20fueran%20necesarios.%20Conforme%20las%20necesidades%20de%20distintos%20pa%C3%ADses%20variaban%20simplemente%20adaptaban%20algunos%20s%C3%ADmbolos%20a%20ASCII.%0ACon%20la%20invenci%C3%B3n%20de%20la%20computadora%20port%C3%A1til%20y%20la%20nueva%20estandarisacion%20de%208%20bit%20ASCII%202%20o%20ampliado%20rellena%20los%20nuevos%20espacios%2C%20sin%20embargo%20los%20teclados%20antiguamente%20semicompatibles%20de%20otros%20lenguajes%20ahora%20deciden%20utilizar%20el%20espacio%20extra%20para%20introducir%20s%C3%ADmbolos%20propios%20lo%20que%20lleva%20a%20una%20tremenda%20incopatibilidad%20en%20el%20software.%0AJapon%20en%20realidad%20necesitaba%20tantos%20s%C3%ADmbolos%20que%20adapto%20varios%20sistemas%20de%20car%C3%A1cter%20encoding%20de%20m%C3%A1s%20de%208%20bytes%20pues%20necesitaban%20muchos%20mas%20s%C3%ADmbolos%2C%20estos%20sistemas%20eran%20adem%C3%A1s%20entre%20si%20incompatibles.%0ASin%20emabrgo%20en%20esos%20tiempos%20era%20com%C3%BAn%20que%20si%20querias%20enviar%20un%20documento%20correctamente%20a%20una%20compa%C3%B1%C3%ADa%20extranjera%20lo%20hicieras%20por%20medio%20de%20Fax.%20Pero%20la%20llegada%20del%20internet%20fue%20lo%20que%20detono%20por%20fin%20la%20necesidad%20de%20una%20estandarisacion%20mundial.%0ASe%20dise%C3%B1a%20el%20Unicode%20Consortium%20para%20resolver%20este%20problema.%20Lo%20que%20hacen%20es%20vincular%20cada%20car%C3%A1cter%20existente%20con%20un%20%E2%80%9Cnumero%20oficial%E2%80%9D%20de%20identificaci%C3%B3n.%20Sin%20embargo%20ese%20numero%20de%20identificaci%C3%B3n%20no%20contiene%20la%20informaci%C3%B3n%20hacerca%20de%20como%20debe%20de%20ser%20representado%2C%20por%20lo%20tanto%20la%20representaci%C3%B3n%20de%20ese%20car%C3%A1cter%20es%20dependiente%20del%20sistema.%0ACuando%20una%20maquina%20interpreta%20s%C3%ADmbolos%20en%20Unicode%20lo%20que%20esta%20haciendo%20es%20representar%20cada%20nuevo%20digito%20necesario%20como%20un%20uno%20y%20un%20cero%3A%0Ahttp%3A%2F%2Fwww.unicode.org%2Fresources%2F%0Ahttp%3A%2F%2Fwww.unicode.org%2Fglossary%2F%0Ahttp%3A%2F%2Fwww.unicode.org%2Ffaq%2Findic.html%0Ahttp%3A%2F%2Fwww.unicode.org%2Ffaq%2Ffont_keyboard.html%0Ahttp%3A%2F%2Fwww.unicode.org%2Ffaq%2Futf_bom.html%0Ahttp%3A%2F%2Fwww.unicode.org%2Ffaq%2Femoji_dingbats.html%0Ahttp%3A%2F%2Fwww.unicode.org%2Ffaq%2Fbasic_q.html%0Ahttp%3A%2F%2Fwww.unicode.org%2Ffaq%2F%0Ahttp%3A%2F%2Fwww.unicode.org%2Fversions%2FUnicode9.0.0%2F%0Ahttp%3A%2F%2Fwww.unicode.org%2Fcharts%2F%0Ahttp%3A%2F%2Fwww.unicode.org%2Fucd%2F%0Ahttp%3A%2F%2Fwww.unicode.org%2Freports%2Findex.html%23standards%0Ahttp%3A%2F%2Fwww.unicode.org%2Fnotes%2F%0A01100001%20%3D%20a%0A110xxxxx%20%2B%2010xxxxxx%0AQuita%20los%20headers%20(110%20%2B%2010)%0A1110xxxx%20%2B%2010xxxxxx%20%2B%2010xxxxxxx%0A1111110x%20%2B%20%E2%80%A6.%0A%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%0A%0A%0A&source=">Publica en LinkedIn</a> </li> <li> <a class="rss" target="_blank" rel="nofollow" title="Subscribete al Feed" href="http://darioarzaba.github.io/feed.xml">Subscribete al RSS</a> </li> </ul> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'https-darioarzaba-github-io'; var disqus_identifier = '/programacion/2017/05/21/ProgramacionUnicode.html'; var disqus_url = 'http://localhost:4000/programacion/2017/05/21/ProgramacionUnicode.html'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> </article> </div> <div class="footer"> <div class="wrapper"> <p class="copyright">&copy; 2017 Dario Arzaba - <a href="http://thehearthofdev.x10.mx" target="_blank">Website</a></p> </div> </div> <script src="/js/jquery.min.js"></script> <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script> <script src="/js/particles.js"></script> </body> </html>
